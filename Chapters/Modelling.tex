\section{Modelling} \label{sec:mod} % Incl. Subsection "Component Models"
The purpose of this section is to outline the linear model of the system. The model is intended to be used as a control model for state-space control with the purpose of minimizing the turbine fore-aft motion. The fore-aft motion dynamics of floating wind turbines are slow (a period of 30 seconds is normal) and the modelling is approached with this in mind: Dynamics which are relatively fast compared to the fore-aft motion dynamics are left out since they are of little importance to the control objective. Examples of such dynamics include but are not limited to: Blade, drivetrain and converter dynamics. Instead such components models are either completely left out or modelled with algebraic equations. 




%\subsection{wtLin component models} \label{sec:compcomps}
%\sout{A Matlab tool named wtLin has been developed by the LaC department in Vestas for creating linear models of their turbines based on simple component models and parameters extracted from VTS parts files. The tool's component models can be connected in loops based on the input-output variables of each component model in a manner chosen by the user. A component can be in the form of a physical system such as a generator or a converter but can also be models of physics which are relevant for the system such as the interaction between the tower movement and the free wind.
%
%The tool takes as input an operating point and a specific set of components. It outputs a connected linear state-space model at that operating point.
%


\subsection{Component models} \label{sec:comp}
A component approach to modelling is adopted where system parts are modelled individually. Each component takes a set of inputs and calculates a set of outputs. If the components contain dynamics they include internal states. Non-linear components are linearised individually at an operating point. Model parameters and operating points are extracted from Vestas Turbine Simulator (VTS) with a tool developed by the LaC department called wtLin. When the components are defined in the correct manner the Matlab \textit{connect()} function can used to create a connected model.

\smallskip
\noindent In this section the relevant component models are derived. The modelled components are:
\begin{itemize}
	\item Drivetrain
	\item Generator
	\item Converter
	\item Aerodynamic torque
	\item Aerodynamic thrust
	\item Rotor wind
	\item Tower fore-aft motion
	\item Pitch system
	\item Full load controller
\end{itemize}
In \cref{sec:comp_connected} the components are connected such that the flow of information in the model is apparent. 


\subsubsection{Drivetrain} \label{sec:comp_drv}
As mentioned in \cref{sec:intro_wtcomponents} the drivetrain connects the rotor with the generator through a gearbox. In a simple \textit{stiff drivetrain} model dampening or spring effects are left out. Thus when a torque is applied at the rotor resulting in a change in twist angle at the rotor the resulting twist angle at the generator is instant and directly proportional to the twist angle at the rotor. In the appendix in \cref{sec:mod_drt_flex} a model of a flexible drivetrain can be found. Due to the relatively fast dynamics of the drivetrain in relation to the WT eigenfrequency these dynamics can be left out. 

The stiff drivetrain consists of two free inertias connected through a gearbox. The drivetrain is modelled from newtons second law for rotation like so:
\begin{equation}\label{eq:wtlin_comp_drivetrain}
	(J_{gL} + J_{r}) \ddot{\theta}_r = T_{r} + T_{g}
\end{equation}
The torques are related to the low-speed rotor side and thus the high-speed generator side inertias are mapped to the low speed side:
\begin{equation} \label{eq:wtlin_comp_inertiamap}
	J_{gL} = J_{g} \left(\dfrac{N_r}{N_g}\right)^2
\end{equation}
where $ N_r $ and $ N_g $ is the number of teeth on the rotor and generator side of the gearbox respectively. The rotor spins at angular velocity $ \dot{\theta}_r = \Omega $.

Given $ \dot{\Omega} = \ddot{\theta}_r $ the model becomes:
\begin{equation}\label{key}
	 \dot{\Omega} = \dfrac{T_{r} + T_{g}}{\left(\dfrac{N_r}{N_g}\right)^2 J_{g} + J_{r}}
\end{equation}

The component inputs are $ \{T_r, T_g\} $ and the output is $ \{\Omega\} $ 



\subsubsection{Generator} \label{sec:comp_generator}
The generator is mechanically connected to the drivetrain and is electrically connected to the converter. It is used to control the rotor speed during PLC by means of the generator torque. 

While the generator model in wtLin includes the generator efficiencies they are left out here for simplicity. In the appendix in \cref{sec:comp_generator_eff} the generator model is derived including efficiencies. No generator dynamics are modelled and thus it is simply an algebraic equation.

The power of a rotating machine can be defined as the product of torque and rotational velocity:
\begin{equation}\label{eq:comp_power_in_rot}
	P_{g} = T_g \left( \dfrac{N_g}{N_r} \right)\omega_L
\end{equation}
The non linear generator model is then defined by rearranging \cref{eq:comp_power_in_rot}:
\begin{equation}\label{eq:comp_gen_torque}
	T_g(P_g, \omega) = \dfrac{P_g}{\omega}
\end{equation}
The linear model of the generator is obtained through a taylor expansion. The definition of the taylor expansion is not included in this report. \cref{eq:comp_power_in_rot} is an algebraic equation describing the absolute value of the generator torque and not its rate of change as it would have been for a model including dynamics. Therefore the taylor expansion linearisation at the operating point yields an affine linear approximation at the operating point:
\begin{equation}\label{eq:comp_gen_taylor}
	T_g( P_g, \omega) \approx T_g(P_{g_o}, \omega_o) + 
	\left. \dfrac{\partial T_g( P_g, \omega)}{\partial P_g} \right |_{P_{g_o},\omega_o} ( P_g-P_{g_o}) + 
	\left. \dfrac{\partial T_g( P_g, \omega)}{\partial \omega} \right |_{P_{g_o},\omega_o} (\omega - \omega_o)
\end{equation}
Below the the generator torque sensitivity to the grid power change term from \cref{eq:comp_gen_taylor} is derived.
\begin{equation} 
	\dfrac{\partial T_g( P_g, \omega)}{\partial P_g} = \dfrac{\partial \left (\dfrac{P_g}{\omega}\right )}{\partial P_g} \label{eq:comp_gen_1} = \dfrac{1}{\omega}
\end{equation}
The generator torque sensitivity to rotational velocity change from \cref{eq:comp_gen_taylor} is then derived:
\begin{align}
	\dfrac{\partial T_g(P_g, \omega)}{\partial \omega} & = \dfrac{\partial \left (\dfrac{P_g}{\omega}\right )}{\partial \omega} \\
	& = P_g \dfrac{\partial \left (\dfrac{1}{\omega}\right )}{\partial \omega} \\
	& = -P_g \, \dfrac{1}{\omega^2}
\end{align}
The above derived generator model is referred to the low-speed generator side by replacing $ \omega $ with $ \omega_L $ where $ \omega_L = \left (\frac{N_r}{N_g} \right ) \omega $ and since the generator model is implemented assuming a stiff drivetrain then $ \omega_L = \Omega $. This yields the affine linear generator model evaluated at the operating point $ (P_{g_o}, \Omega_o) $:
\begin{equation}
	T_g(P_g, \Omega) \approx \dfrac{P_{g_o}}{\omega_o} + \left. \dfrac{1}{\dfrac{N_g}{N_r} \Omega} \right |_{P_{g_o},\Omega_o} (P_g - P_0) \\ 
	\left. - P_g \, \dfrac{1}{\left( \dfrac{N_g}{N_r} \Omega \right)^2} \right |_{P_{g_o},\Omega_o} (\Omega - \Omega_o)
\end{equation}
The goal is to have a linear model of the generator and therefore the change in the generator torque from the operating point is defined:
\begin{equation}
	\hat T_g(P_g, \Omega) \approx \left. \dfrac{1}{\dfrac{N_g}{N_r} \Omega} \right |_{P_{g_o},\Omega_o} (P_g - P_0) \\ 
	\left. - P_g \, \dfrac{1}{\left( \dfrac{N_g}{N_r} \Omega \right)^2} \right |_{P_{g_o},\Omega_o} (\Omega - \Omega_o)
\end{equation}
where $ \hat T_g = T_g - T_{g_o} $.

When the model is linearised in a FLC operating point P is constant and therefore the first part is also zero. The second part is the \textit{negative damping} term which yields and increase in the generator torque when the rotational speed decreases which even further decreases the rotational speed.

The component model input is $ \{P, \Omega\} $ and the output is $ \{T_g\} $


\subsubsection{Converter} \label{sec:comp_conv_unity}
The converter connects the generator with the grid and it is controlled by the power controller. It handles the power flow from the generator to the grid.

The dynamics of modern converters are much faster than the rotor and tower dynamics and therefore it is simply modelled as an algebraic equation as a direct feed-through:
\begin{equation}\label{eq:comp_convdft}
	P_{conv} = P_{ref}
\end{equation}
In other words the converter is treated as a \textit{black box} system which, when given a power reference, delivers a power equal to said power reference instantly.

The input is $ \{P_{conv}\} $ and the output is $ \{P_{ref}\} $


\subsubsection{Aerodynamic torque} \label{sec:comp_aero_torque}
In \cref{sec:theory_fowt_challenges} it was explained that it was convenient to use the pre-calculated thrust coefficient values $ C_T $ to determine the stationary thrust. Likewise pre-calculated power coefficient tables $ C_p $ can be used to calculate the stationary torque. Both $ C_p $ and $ C_T $ are extracted and linearised at the operating point with wtLin.

In \cref{eq:power_w_Cp} the extractable power from the free wind was defined. When combining this equation with the definition of power in a mechanical system the torque on the rotor can be expressed:
\begin{equation}\label{eq:comp_Mrot_lambda}
	T_r(\Omega, \lambda) = \dfrac{1}{2} \rho A_d v^3 \, C_p(\theta, \lambda) \dfrac{1}{\Omega}
\end{equation}
The TSR is dependent on $ \Omega $ and $ v $ and thus the rotor torque model ends up being dependent on $ \theta $, $ \Omega $ and $ v $:
\begin{equation}\label{eq:comp_Mrot_wind}
	T_r(\theta, \Omega, v) = \dfrac{1}{2} \rho A_d v^3 \, C_p(\theta, \Omega, v) \dfrac{1}{\Omega}
\end{equation}
The model is linearised at an operating point with a taylor expansion $ (\theta_o, \Omega_o, v_o) $:
\begin{align}
	T_r(\theta, \Omega, v) \approx T_r(\theta_o, \Omega_o, v_o) 
	& + \left. \dfrac{\partial T_r(\theta, \Omega, v)}{\partial \theta} \right |_{\theta_o, \Omega_o, v_o} ( \theta-\theta_o) \\
	& + \left. \dfrac{\partial T_r(\theta, \Omega, v)}{\partial \Omega} \right |_{\theta_o, \Omega_o, v_o} ( \Omega-\Omega_o) \\
	& + \left. \dfrac{\partial T_r(\theta, \Omega, v)}{\partial v} \right |_{\theta_o, \Omega_o, v_o} ( v - v_o)
\end{align}
The derivation of the linear model is not included for this component and for the following components since the concept of linearising through a taylor expansion was demonstrated in the \hyperref[sec:comp_generator]{\textbf{generator component model section}}. Retrieving a linear model with the \textit{jacobian()} Matlab functions is furthermore a trivial task.

The component inputs are $ \{\theta, \Omega, v\} $ and the output is $ \{T_r\} $

\subsubsection{Aerodynamic thrust} \label{sec:comp_aero_thrust}
The stationary rotor thrust force $ F_T $ is calculated from the pre-calculated thrust table $ C_T $ yielding the model:
\begin{equation} \label{eq:comp_aero_thrust}
	F_T(\theta, \Omega, v) = \dfrac{1}{2} \rho A_d v^2 C_T(\theta, \Omega, v)
\end{equation}
$ C_T $ is a mapping from the pitch angle, rotor velocity and wind speed to a total stationary rotor thrust.

The model is linearised with a taylor expansion.

The component inputs are $ \{\theta, \Omega, v \} $ and the output is $ \{F_T\} $


\subsubsection{Rotor wind} \label{sec:comp_rot_wind}
There is an interaction between the tower fore-aft movement and the wind speed which ultimately results in a constantly changing wind speed as seen from the rotor's point of view. Thus it is necessary to calculate the \textit{free} wind speed as observed from the rotors point of reference. This is simply done by subtracting the free wind speed $ v_0 $ from the hub translational velocity in the heave (\textbf{y}) direction $ v_y $. Note that the \textbf{x} and \textbf{y} directions are interchanged in the Vestas DOF notation in relation to the DOF notation used in most literature. This is further touched upon in the following section. 
\begin{equation}\label{eq:comp_rotorwind}
	v_{0_{rot}} = v_{0} - v_y
\end{equation}
$ v_{0_{rot}} $ is \underline{not} the rotor wind which is the wind speed at the rotor plane but the free wind modified by the turbine velocity.

The component inputs are $ \{v_0, v_y\} $ and the output is $ \{v_{0_{rot}}\} $


\subsubsection{Tower fore-aft movement} \label{sec:comp_foreaft_mod}
The fore-aft motion is both the \textit{surge} and \textit{pitch} motion of turbine structure. In most literature the DOF notation is the same as seen in \cref{fig:fowt_coordinates}. This notation will hereinafter be denoted the \textit{"normal DOF notation"}. Vestas uses another notation which will be denoted the \textit{Vestas DOF notation}: Most importantly \textbf{x} and \textbf{y} are interchanged such that for the Vestas notation y is in the \textit{surge} direction and x in the \textit{sway} direction and \textit{pitch} in the normal DOF notation is called \textit{tilt} in Vestas DOF notation. This document \underline{for the most part} adopts the normal DOF notation when discussing the DOFs and one is thus directed to \cref{fig:fowt_coordinates} if in doubt about which movement is the subject of discussion. Since Vestas and the wtLin tool adopts the Vestas DOF notation the equations presented make use of this notation as well.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\linewidth]{Graphics/wtLinForeAftMotionModel.pdf}
	\caption{Illustration of the mass spring damper approximation of the fore-aft tower movement}
	\label{fig:wtLin_fore-aft_diagram}
\end{figure}
The fore-aft movement is modelled by a mass-spring-damper system whose movement is defined to be at nacelle height. This choice is initially made because a sensor in VTS is currently located at nacelle height which is utilized by the FATD controller. For simplicity it is assumed that the foundation does not translate in any direction and therefore the translation at nacelle height is due to the pitching $ \phi $ of the structure. An illustration of this is seen in \cref{fig:wtLin_fore-aft_diagram}. This is obviously a heavily simplified model. It assumes a stiff nacelle-tower-foundation structure and the stability and dynamics from the hydrodynamic, buoyancy, ballast and mooring line forces are approximated into the mass, spring and damper coefficients. Furthermore the mass $ M $ represents the inertia of the structure pitching. The governing equations for the mass-spring-damper system are:
\begin{equation}\label{eq:comp_fore-aft_ay1}
	\ddot{p}_y m = F_{rot} - F_d + F_s
\end{equation}
where $ p_y $ is the heave translation position, $ F_{rot} $ is the rotor force and $ F_d $ and $ F_s $ are the damper and spring forces respectively.

when isolating $ \ddot{p}_y $ and expanding $ F_d $ and $ F_s $, \cref{eq:comp_fore-aft_ay1} becomes:
\begin{equation}\label{eq:comp_fore-aft_ay2}
	\ddot{p}_y = \dfrac{F_{rot} - b \dot{p}_y - k p_y}{m}
\end{equation}
where $ b $ and $ k $ are the damper and spring coefficients respectively.

We then define:
\begin{align}
	\dot{v}_y & = \ddot{p}_y \label{eq:comp_fore-aft_ay} \\
	\dot{p}_y & = v_y \label{eq:comp_fore-aft_vy}
\end{align}
which yields the fore-aft tower model:
\begin{align}
	\dot{v}_y & = \dfrac{F_{rot} - b v_y - k p_y}{m}  \label{eq:comp_fore-aft_1} \\
	\dot{p}_y & = v_y \label{eq:comp_fore-aft_2}
\end{align}
Furthermore the fore-aft tower model transfer function (TF) from rotor thrust $ F_{rot} $ to heave translation $ p_y $ can be written on the standard second order TF form (seen in \cref{eq:std_tf}) in the laplace domain as seen below:
\begin{equation}\label{eq:comp_fore_aft_tf}
	\dfrac{p_y}{F_{rot}} = \dfrac{\dfrac{1}{m}}{s^2 + \dfrac{b}{m} s + \dfrac{k}{m}}
\end{equation}
From comparison to the standard TF it can be derived that:
\begin{align}
	k & = (2 \pi f_{eig})^2 m \label{eq:comp_fore_aft_tf_k} \\
	b & = 2 \zeta \sqrt{k m} \label{eq:comp_fore_aft_tf_b}
\end{align}
where $ f_{eig} $ represents the natural frequency of the system while $ \zeta $ is the damping factor. 

This leaves three new tuning parameters to be considered: $ m $, $ f_{eig} $ and $ \zeta $. Since this simple model is a crude approximation of a much more complex system these parameters can not be directly inferred from any parts files of VTS. They need to be tuned such that the response of the model fits the real system as well as possible. In the appendix in \cref{sec:app_mod_foreaft_fitting} this process is further described in detail. With an operating point of 16 m/s the parameters were found to be:
\todo[inline]{Indsæt parametre her. Jeg skal lige se om der skal laves noget om nu hvor theta -> vy checkes ud}
\begin{itemize}
	\item $ m =  $
	\item $ f_{eig} =  $
	\item $ \zeta =  $
\end{itemize}

\medskip
The second order TF standard form:
\begin{equation}\label{eq:std_tf}
	T(s) = \dfrac{\omega_n^2}{s^2 + 2 \zeta \omega_n s + \omega_n^2}
\end{equation}

The component input is $ \{F_{rot} \} $ and the output is $ \{p_y, v_y\} $


\subsubsection{Pitch system} \label{sec:comp_pitch}
The pitch system consists of the local pitch controller and the mechanical and electrical parts that make out the pitching system. The pitch controller takes the pitch reference $ \theta_{ref} $ and the FATD contribution $ \theta_{fatd} $ as input and outputs a voltage in a range which through the electrical and mechanical system translates to a pitch position. 

While the pitch system dynamics are not fast by ordinary standards they can be assumed to be fast enough with regards to the control objective to be left out. Therefore the pitch system is simply modelled as a direct feed-through. In the appendix in \cref{sec:comp_pitch_dyn} pitch system dynamics are approximated with a single order low-pass filter. 
\begin{equation}\label{eq:comp_pitch_freq}
	\theta = \theta_{ref} + \theta_{fatd}
\end{equation}
The component inputs are $ \{\theta_{ref}, \theta_{fatd}  \} $ and the output is $ \{\theta \} $


\subsubsection{Full load controller} \label{sec:comp_flc}
The FLC is a PI controller on the form seen in \cref{fig:PIcontroller}. The output of the FLC controller is the pitch reference $ \theta_{ref} $ which is added with the FATD pitch reference contribution $ \theta_{FATD} $ if the FATD is active. The controller designed later in \cref{sec:ctrl-design} acts as both the FLC and FATD. Therefore this FLC component is only included in the model to see how the turbine behaves under normal operation.
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.5\linewidth]{Graphics/PiController.pdf}
	\caption{Block diagram of the PI controller on the \textit{$T_i$} form.}
	\label{fig:PIcontroller}
\end{figure}
When including the sensitivity gain scheduling the laplace domain controller is therefore:
\begin{equation}\label{eq:comp_flc}
	\theta_{ref}(s) = K_{gs,dP/d\theta} (K_{p, \theta} + K_{p, \theta} \dfrac{1}{T_{i, \theta} s}) e(s)
\end{equation}
%The time domain FLC controller is derived:
%\begin{align}
%	\theta_{ref}(s) & = K_{gs,dP/d\theta} K_{p, \theta} \dfrac{T_{i, \theta} s + 1}{T_{i, \theta} s} e(s) \\
%	\theta_{ref}(s) & = K_{gs,dP/d\theta} K_{p, \theta} (\dfrac{T_{i, \theta} s}{T_{i, \theta} s} + \dfrac{1}{T_{i, \theta} s}) e(s) \\
%	\theta_{ref}(s) & = K_{gs,dP/d\theta} K_{p, \theta} e(s) +  K_{gs,dP/d\theta} K_{p, \theta} \dfrac{1}{T_{i, \theta} s} e(s) \\
%	\theta_{ref}(s) s & = K_{gs,dP/d\theta} K_{p, \theta} e(s) s +  K_{gs,dP/d\theta} K_{p, \theta} \dfrac{1}{T_{i, \theta}} e(s)
%\end{align}
The time domain model can be derived by rearranging and taking the inverse laplace transform which yields:
\begin{equation}\label{eq:comp_flc_time}
	\dot{\theta}_{ref} = K_{gs,dP/d\theta} (K_{p, \theta} \dot{e} + K_{p, \theta} \dfrac{1}{T_{i, \theta}} e)
\end{equation}


The component input is $ \{e \} $ and the output is $ \{\theta_{ref} \} $


%\subsubsection{Partial Load Controller (PLC)} \label{sec:comp_plc}
%The PLC is a PI-controller on the same form as the \hyperref[sec:comp_flc]{\textbf{FLC}} controller:
%\begin{equation}\label{eq:comp_plc}
%	P_{ref}(s) = K_{gs} (K_{p, P} + K_{p, P} \dfrac{1}{T_{i, P} s}) e(s)
%\end{equation}
%
%Which likewise in the time domain is:
%\begin{equation}\label{eq:comp_plc_time}
%	\dot{P}_{ref} = K_{gs P} K_{p, P} \dot{e} +  K_{gs P} K_{p, P} \dfrac{1}{T_{i, P}}e
%\end{equation}
%
%The component inputs are $ \{e \} $ and the outputs are $ \{P_{ref} \} $


\subsection{The connected model} \label{sec:comp_connected}
In the previous section all individual components models were defined and the non-linear models are linearised at an operating point. When the components are connected we are left with a system which is only a function of states and inputs with the states deriving from the components with modelled dynamics. We can then set up a continuous linear state-space system on the following form:
\begin{equation}\label{eq:state-space-sys}
	\begin{split}
		\dot x &= A x + B u + B_d d \\
		y &= Cx
	\end{split}
\end{equation}
Where $ \dot x $ is the time derivative of the state vector, $ u $ the input vector and $ d $ the disturbance vector. A distinction is made between $ u $ and $ d $ because $ u $ represents the controllable inputs which will eventually be the output of the designed controller while $ d $ are uncontrollable inputs such as the wind which affect the system beyond our control. Achieving a system model on this form is necessary for conventional linear state-space controller design.

In xxx a diagram of the connected model can be found. The outputs of most component models can be observed entering adjacent components. The inputs to the full system can be observed to be the rotor speed reference $ wRef $ the power reference $ Pref $ and the free wind speed $ vfree $. It should be highlighted again that the system contains the FLC controller component described in \cref{sec:comp_flc} which like the other components is embedded in the $ A $ and $ B $ matrices, essentially making it a closed-loop system. When the controller is made in \cref{sec:ctrl-design} the FLC is removed such that the designed controller regulates both rotor speed and the turbine tower top movement.

\smallskip
Outputs can be defined from the sensors which are expected to be available and if the outputs the states then the output matrix $ C $ only contains ones and zeros.

The resulting state space system becomes:

\begin{equation}\label{eq:xdot}
	\dot{\begin{bmatrix} \theta_{ref} \\
						p_y \\ 
						v_y \\
						\Omega \end{bmatrix}} = 
	\begin{bmatrix} A_{11} & A_{12} & A_{13} & A_{14}\\ 
					A_{21} & A_{22} & A_{23} & A_{24}\\ 
					A_{31} & A_{32} & A_{33} & A_{34}\\
					A_{41} & A_{42} & A_{43} & A_{44}\end{bmatrix}
	\begin{bmatrix} \theta_{ref} \\
					p_y \\ 
					v_y \\
					\Omega \end{bmatrix} + 
	\begin{bmatrix} B_{11} & B_{12} \\
					B_{21} & B_{22} \\
					B_{31} & B_{32} \\
					B_{41} & B_{42} \end{bmatrix}
	\begin{bmatrix} \omega_{Ref} \\ 
					P_{ref} \end{bmatrix}
\end{equation}

with the output
\begin{equation}\label{eq:y}
	\begin{bmatrix} p_y \\ 
					v_y \\
					\Omega \end{bmatrix} = 
	\begin{bmatrix}	0 	& 1 	& 0 	& 0 \\ 
					0 	& 0 	& 1 	& 0 \\
					0 	& 0 	& 0 	& 1 \end{bmatrix}
	\begin{bmatrix} \theta_{ref} \\
					p_y \\ 
					v_y \\
					\Omega \end{bmatrix}
\end{equation}


\subsubsection{System evaluation}
A linear system model has now been derived at an operating point and before using it to make a state-space controller some key evaluations should be made. Firstly stability is checked and secondly controllability and observability.

\medskip
An important characteristic of any system is its stability. Some system $ \dot x = f(x) $ which is linearised at an operating point $ x_0 $ such that $ A = \left. \dfrac{\partial f}{\partial x} \right| _{x_0} $ is stable in a vicinity around the origin iff
\begin{equation}\label{eq:stability}
	Re\{\lambda_i\} < 0 \;\;\; \text{for} \;\;\; 1 \leq i \leq n
\end{equation}
with $ \lambda_i $ being the eigenvalues of the system. For an inherently linear system if \cref{eq:stability} then no matter where the states are initialized they will always return to an equilibrium point. For a non-linear system which is linearised at an operating point it only means that the system is stable in some vicinity around that operating point. There is furthermore no guarantee that stability holds for all operating points. The poles of $ A $ from \cref{eq:xdot} all have negative real values and it is thus stable.

\medskip
Next it is checked if the rank of the controllability matrix is equal to the number of states.

\medskip
Next is is checked if the rank of the observability matrix is equal to the number of states.

